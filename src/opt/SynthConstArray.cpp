#include "SMTPasses.h"
#include "LoopPasses.h"
#include "../utils/Matcher.h"

using namespace sys;
using namespace smt;

// Generated by expr-gen.ts
// All combinations up to 2 instructions from the following:
//  add, sub, and, or, xor
SynthConstArray::SynthConstArray(ModuleOp *module): Pass(module) {
  auto _x = ctx.create(BvExpr::Var, "x");
  auto _c0 = ctx.create(BvExpr::Var, "c0");
  auto _c1 = ctx.create(BvExpr::Var, "c1");
  // === Manually added ===
  candidates.reserve(150);
  candidates.push_back(_x);
  // === Done ===
  candidates.push_back(ctx.create(BvExpr::Add, _x, _x));
  candidates.push_back(ctx.create(BvExpr::Add, _x, _c0));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, _c0));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, _x));
  candidates.push_back(ctx.create(BvExpr::And, _x, _c0));
  candidates.push_back(ctx.create(BvExpr::Or, _x, _c0));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, _c0));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::Add, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::Sub, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::Sub, _c0, _x)));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::And, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::Or, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Add, _x, ctx.create(BvExpr::Xor, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::Add, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::Sub, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::Sub, _c1, _x)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::And, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::Or, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Add, _c0, ctx.create(BvExpr::Xor, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::Add, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::Sub, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::Sub, _c0, _x)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::And, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::Or, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Sub, _x, ctx.create(BvExpr::Xor, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::Add, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::Sub, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::Sub, _c1, _x)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::And, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::Or, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Sub, _c0, ctx.create(BvExpr::Xor, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::Add, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::Sub, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::Sub, _c0, _x)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::And, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::Or, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::And, _x, ctx.create(BvExpr::Xor, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::Add, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::Sub, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::Sub, _c1, _x)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::And, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::Or, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::And, _c0, ctx.create(BvExpr::Xor, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::Add, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::Sub, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::Sub, _c0, _x)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::And, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::Or, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Or, _x, ctx.create(BvExpr::Xor, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::Add, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::Sub, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::Sub, _c1, _x)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::And, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::Or, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Or, _c0, ctx.create(BvExpr::Xor, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::Add, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::Sub, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::Sub, _c0, _x)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::And, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::Or, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Xor, _x, ctx.create(BvExpr::Xor, _x, _c0)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::Add, _x, _x)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::Add, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::Sub, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::Sub, _c1, _x)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::And, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::Or, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Xor, _c0, ctx.create(BvExpr::Xor, _x, _c1)));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Add, _x, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Add, _x, _x), _c0));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Add, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Add, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Sub, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Sub, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Sub, _c0, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Sub, _c0, _x), _c1));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::And, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::And, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Or, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Or, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Xor, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Add, ctx.create(BvExpr::Xor, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Add, _x, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Add, _x, _x), _c0));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Add, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Add, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Sub, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Sub, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Sub, _c0, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Sub, _c0, _x), _c1));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::And, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::And, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Or, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Or, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Xor, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Sub, ctx.create(BvExpr::Xor, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Add, _x, _x), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Add, _x, _x), _c0));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Add, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Add, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Sub, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Sub, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Sub, _c0, _x), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Sub, _c0, _x), _c1));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::And, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::And, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Or, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Or, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Xor, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::And, ctx.create(BvExpr::Xor, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Add, _x, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Add, _x, _x), _c0));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Add, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Add, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Sub, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Sub, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Sub, _c0, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Sub, _c0, _x), _c1));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::And, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::And, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Or, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Or, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Xor, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Or, ctx.create(BvExpr::Xor, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Add, _x, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Add, _x, _x), _c0));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Add, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Add, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Sub, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Sub, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Sub, _c0, _x), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Sub, _c0, _x), _c1));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::And, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::And, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Or, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Or, _x, _c0), _c1));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Xor, _x, _c0), _x));
  candidates.push_back(ctx.create(BvExpr::Xor, ctx.create(BvExpr::Xor, _x, _c0), _c1));
}

namespace {

Rule constIncr("(addl x 'a)");

}

Op *SynthConstArray::reconstruct(smt::BvExpr *expr, Op *subscript, int c0, int c1) {
  switch (expr->ty) {
  case BvExpr::Var:
    if (expr->name == "x")
      return subscript;
    if (expr->name == "c0")
      return builder.create<IntOp>({ new IntAttr(c0) });
    if (expr->name == "c1")
      return builder.create<IntOp>({ new IntAttr(c1) });
    assert(false);
  case BvExpr::Add: {
    Value l = reconstruct(expr->l, subscript, c0, c1);
    Value r = reconstruct(expr->r, subscript, c0, c1);
    return builder.create<AddIOp>({ l, r });
  }
  case BvExpr::Sub: {
    Value l = reconstruct(expr->l, subscript, c0, c1);
    Value r = reconstruct(expr->r, subscript, c0, c1);
    return builder.create<SubIOp>({ l, r });
  }
  case BvExpr::And: {
    Value l = reconstruct(expr->l, subscript, c0, c1);
    Value r = reconstruct(expr->r, subscript, c0, c1);
    return builder.create<AndIOp>({ l, r });
  }
  case BvExpr::Or: {
    Value l = reconstruct(expr->l, subscript, c0, c1);
    Value r = reconstruct(expr->r, subscript, c0, c1);
    return builder.create<OrIOp>({ l, r });
  }
  case BvExpr::Xor: {
    Value l = reconstruct(expr->l, subscript, c0, c1);
    Value r = reconstruct(expr->r, subscript, c0, c1);
    return builder.create<XorIOp>({ l, r });
  }
  default:
    assert(false);
  }
}

void SynthConstArray::run() {
  LoopAnalysis analysis(module);
  analysis.run();
  auto forests = analysis.getResult();

  // Find out const arrays.
  auto gMap = getGlobalMap();
  auto gets = module->findAll<GetGlobalOp>();
  for (auto get : gets) {
    for (auto use : get->getUses()) {
      if (isa<StoreOp>(use)) {
        gMap.erase(NAME(get));
        break;
      }
    }
  }

  // The remaining things in `gMap` are only read from,
  // so they're const.
  for (auto [k, v] : gMap) {
    if (v->has<FloatArrayAttr>())
      continue;

    // Only deal with integers.
    auto iarr = v->get<IntArrayAttr>();
    if (iarr->allZero)
      continue;

    auto ptr = iarr->vi;
    auto size = iarr->size;
    if (size >= 256)
      continue;

    // Try to work out a low-cost representation.
    BvExpr *correct = nullptr;
    int c0, c1;
    for (auto expr : candidates) {
      // We need to ensure that for all `i <= size`, the expression is correct.
      // We use SMT solver to find out the constants.

      // Solvers cannot be reused currently. Don't know how to improve it.
      BvSolver solver;
      // Find out the constants by assigning some value to `i`.
      int i = size / 2;
      solver.assign("x", i);
      auto vi = ctx.create(BvExpr::Const, ptr[i]);
      auto eq = ctx.create(BvExpr::Eq, expr, vi);

      // Validate that every element is correct.
      if (!solver.infer(eq))
        continue;

      bool good = true;
      for (int i = 0; i < size; i++) {
        if (solver.eval(expr, { { "x", i } }) != ptr[i]) {
          good = false;
          break;
        }
      }
      if (good) {
        correct = expr;
        if (solver.has("c0"))
          c0 = solver.extract("c0");
        if (solver.has("c1"))
          c1 = solver.extract("c1");
        break;
      }
    }

    if (!correct)
      continue;

    std::cerr << "found: " << correct << "\n";

    // Now replace every load to this const array.
    std::vector<Op*> getself;
    for (auto get : gets) {
      if (NAME(get) == k)
        getself.push_back(get);
    }

    for (auto get : getself) {
      auto uses = get->getUses();
      const auto &forest = forests[get->getParentOp<FuncOp>()];
      for (auto use : uses) {
        // Constant places should have been done elsewhere.
        // We focus on loops.
        if (!isa<PhiOp>(use))
          continue;

        auto parent = use->getParent();
        // This phi is probably a loop header.
        // The only place it can come from is SCEV.
        LoopInfo *loop = nullptr;
        for (auto l : forest.getLoops()) {
          if (l->header == parent)
            loop = l;
        }
        if (!loop)
          continue;

        auto latch = loop->getLatch();
        auto latchval = Op::getPhiFrom(use, latch);
        int latchidx = latchval != use->DEF(0);

        // We don't know whether preheader exists currently.
        auto preval = use->DEF(1 - latchidx);
        auto from = FROM(use->getAttrs()[1 - latchidx]);

        // This latchval should be an addition of fixed step.
        if (!constIncr.match(latchval))
          continue;

        auto step = V(constIncr.extract("'a"));
        
        // If there's no induction variable, then we synthesize one.
        auto induction = loop->getInduction();
        if (!induction) {
          // Add a zero from preheader.
          builder.setBeforeOp(preval);
          auto zero = builder.create<IntOp>({ new IntAttr(0) });

          builder.setBeforeOp(use);
          auto phi = builder.create<PhiOp>({ zero }, { new FromAttr(from) });

          builder.setBeforeOp(latchval);
          // Step of arrays will be sizeof(int) times larger.
          auto cstep = builder.create<IntOp>({ new IntAttr(step / 4) });
          auto incr = builder.create<AddIOp>({ phi, cstep });
          phi->pushOperand(incr);
          phi->add<FromAttr>(latch);

          induction = phi;

          // Replace branch condition.
          auto term = latch->getLastOp();
          if (isa<BranchOp>(term) && isa<LtOp>(term->DEF())) {
            auto cond = term->DEF();
            auto stop = cond->DEF(1);

            // Create a new stop value for the induction variable.
            builder.setAfterOp(stop);
            auto diff = builder.create<SubLOp>({ stop->getResult(), preval });
            auto four = builder.create<IntOp>({ new IntAttr(4) });
            auto cstop = builder.create<DivIOp>({ diff, four });

            // Change the condition.
            builder.setBeforeOp(cond);
            auto lt = builder.create<LtOp>({ incr, cstop });
            term->setOperand(0, lt);
          }
        }

        // Find all loads related to induction variable.
        // TODO: also deal with things like `x[i + 'a]`.
        auto phiuses = use->getUses();
        for (auto phiuse : phiuses) {
          if (isa<LoadOp>(phiuse)) {
            // Substitute this with a reconstruction.
            auto op = reconstruct(correct, induction, c0, c1);
            phiuse->replaceAllUsesWith(op);
            phiuse->erase();
          }
        }
      }
    }
  }
}
